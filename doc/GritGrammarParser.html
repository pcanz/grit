<h1>Grit Grammar Parser</h1>
<p>Grit is a grammar language that can transform an input string into any data type that an application program requires.</p>
<p>A Grit grammar can contain both PEG (Parser Expression Grammar) rules, and RegExp (Regular Expression) rules. The rules can include optional semantic actions to translate the rule results.</p>
<p>This note will discuss Grit as used in JavaScript, so some of the details will be specific to JavaScript, but the PEG rules, and the way that the Grit grammar language operates should be the same in any other host programming language.</p>
<h2>Overview Example</h2>
<p>The first example shows a complete JavaScript program that can evaluate simple arithmetic expressions -- which is the &quot;Hello World&quot; example for grammar languages. Don't worry about the details, they will be explained shortly, but if you are familiar with regular expressions and the general idea of grammar rules then you will probably follow how it all works.</p>
<p>In a Grit grammar the PEG grammar rules are introduced with a <code>:=</code> symbol, and the RegExp rules are introduced with a <code>:~</code>. The optional <code>::</code> introduces a semantic action to translate the rule result.</p>
<pre><code class="language-eg">	var Grit = require(&quot;./grit.js&quot;);

	// The JavaScript ES6 tag`...` syntax is used to define the grammar rules:

	var arith = Grit`
		exp    := sum (addop sum)*       :: reduce
		sum    := term (mulop term)*     :: reduce
		term   := num / &quot;(&quot; exp ')'      :: term
		addop  :~ \s*([-+])              :: string
		mulop  :~ \s*([*/])              :: string
		num    :~ \s*([0-9]+)\s*         :: number
	`;

	// Semantic action functions, defined using JavaScript ES6 =&gt; arrow function notation:

	arith.string = (_, str) =&gt; str

	arith.number = (_, num) =&gt; Number(num)

	arith.term = (a, b, c) =&gt; b || a

	arith.reduce = (x, ops) =&gt; ops.reduce((z,[op,y]) =&gt; arith[op](z,y), x)

	arith['+'] = (n,m) =&gt; n+m;
	arith['-'] = (n,m) =&gt; n-m;
	arith['*'] = (n,m) =&gt; n*m;
	arith['/'] = (n,m) =&gt; n/m;

	// Now use the grammar to evaluate a string and return a numeric value:

	var x = arith.parse(&quot;1+2*(3+4)-5&quot;);
	console.log(x); // 10
</code></pre>
<p>JavaScript 2015 ES6 has tag template strings that can be used to embed DSLs (Domain Specific Languages), and this works well for Grit. Earlier versions of JavaScript are not quite as neat.</p>
<p>The semantic action following the :: symbol is the name of a function to translate the rule result. A semantic action can be thought of as a type translator that transforms the parser rule result into the desired data type.</p>
<p>The result of a parse using the <code>arith</code> grammar is a numeric value. A different grammar may use different semantic actions to translate an input string into an ouput string, or some other application data type. If there are no semantic actions then the rules will build a parse tree of JavaScript Array elements, which an application program may process in any way it wants.</p>
<h2>RegExp Rules</h2>
<p>Lets start with a Grit grammar parser to match dates expressed in a <code>month/day/year</code> format, such as: <code>3/4/2015</code>. This grammar is just a single RegExp rule:</p>
<pre><code class="language-eg">	var date = Grit`
		mdy :~ (\d\d?)/(\d\d?)/(\d{4})
	`;

	var d = date.parse(&quot;3/4/2015&quot;);

	// d = [&quot;3/4/2015&quot;, &quot;3&quot;, &quot;4&quot;, &quot;2015&quot;, rule: 'mdy']
</code></pre>
<p>A RegExp rule can contain any regular expression (as documented for the host programming language). The result is an array of string values, first the overall match, then any bracket sub-group matches (three in this example), plus a rule name property with the name of the rule that produced this result.</p>
<p>The RegExp rules may contain extra white-space to make them more readable, but all white-space is removed from the rule body (except inside square brackets) before it is given to the RegExp engine as a pattern to match. A space character can only be matched if it is inside square brackets.</p>
<p>The date RegExp is simple enough, but larger regular expressions can become quite difficult to work with. To further help readability the Grit grammar allows a regular expression to be broken out into component parts like this:</p>
<pre><code class="language-eg">	var mdy = Grit`
		mdy   :~ (%month) / (%day) / (%year)
		month :~ \d \d?
		day   :~ \d \d?
		year  :~ \d{4}
	`;
</code></pre>
<p>The <code>%rule</code> is a placeholder that is replaced by the body of the named rule (which must be defined after the placeholder). This grammar has four rules, but after the placeholders are resolved the <code>mdy</code> rule is the only rule needed to match the complete date format. This grammar and the previous single rule grammar will parse the input with exactly the same RegExp expression, so they will have identical performance, and generate the same result.</p>
<p>The JavaScript regular expression engine is very fast, and it can express quite complex pattern matching rules. It is usually a good idea to match as much as possible with Regexp rules. On the other hand PEG rules make a better specification that is portable across host programming languages.</p>
<h2>PEG Rules</h2>
<p>The PEG rules can express sequences and choices.</p>
<p>An example of a sequence rule:</p>
<pre><code class="language-eg">	s := p q r
</code></pre>
<p>The s rule will match an input string that matches the p rule, followed by a q rule, and then an r rule, or it will fail to match the input.</p>
<p>The result of this rule (without a semantic action) will be a list with three terms:</p>
<pre><code class="language-eg">	[p, q, r]
</code></pre>
<p>Of course these terms are also rule results, so they will also return list structures:</p>
<pre><code class="language-eg">	[[p...], [q...], [r...]]
</code></pre>
<p>An example of a choice rule:</p>
<pre><code class="language-eg">	e := p / q / r
</code></pre>
<p>The e rule will match either: p, or q, or r, or fail. The choice is the first to match and it is exclusive, so the q rule can match if and only if the p rule fails to match.</p>
<p>The result of a rule is always a list, in this case it will contain a single term, the result of the first choice that matched:</p>
<pre><code class="language-eg">	[p], or [q], or [r], or e fails
</code></pre>
<p>The PEG rules allow an expression to employ the usual suffix repeat operators:</p>
<pre><code class="language-eg">	r := x? y+ z*
</code></pre>
<p>The x? will match x once, or not at all (and never fail). The y+ will match y one or more times (or fail). The z* will match z any number of times (and never fail).</p>
<p>The repeat operators generate a list of results that may contain zero or more items. The r rule will always generate a list of three items. The x? or z* results may be empty lists, for example:</p>
<pre><code class="language-eg">	[[], [y, ...], [z, ...]]
</code></pre>
<p>The PEG rules also allow an expression to employ the PEG prefix operators:</p>
<pre><code class="language-eg">	t := !x &amp;y
</code></pre>
<p>The <code>!x</code> ensures that there is not an <code>x</code> at this point in the input. The <code>&amp;y</code> ensures that there is a <code>y</code> that will match, but it does not consume the <code>y</code>. If the <code>t</code> rule matches then the result will be a list containing two empty lists: <code>[[], []]</code>.</p>
<p>Brackets can be used to group sub expressions:</p>
<pre><code class="language-eg">	g = p (x y)*
</code></pre>
<p>The result will be a list that always contains two items: first a <code>p</code> result then a list containing zero or more lists of <code>x</code> and <code>y</code> results:</p>
<pre><code class="language-eg">	[ p, [[x, y], [x, y], ... ] ]
</code></pre>
<p>A Grit PEG rule can refer to other PEG rules and to RegExp rules. Without RegExp terms (implicit or explicit) the PEG rules themselves do not have the ability to match input characters, they always use a RegExp rule to actually match any input.</p>
<p>In summary:</p>
<pre><code class="language-eg">	x y z  =&gt; [x, y, z]

	x*     =&gt; [x, ...]

	(x y)  =&gt; [x, y]

	(x y)* =&gt; [[x, y], ...]
</code></pre>
<h2>PEG And RegExp Rules</h2>
<p>To see why we need PEG rules in addition to RegExp rules let's try to match an iterative expression with a RegExp rule. For example, to parse a list of numbers that are added together, such as: &quot;1+2-3+4&quot;. We could try this:</p>
<pre><code class="language-eg">	var sum = Grit`
		sum  :~ %num (%add %num)*
		add  :~ [+-]
		num  :~ [0-9]+
	`;
</code></pre>
<p>This RegExp will match the input correctly, but only the last match of the repeated expression is returned by the RegExp engine. Parsing &quot;1+2-3+4&quot; will generate a result like this:</p>
<pre><code class="language-eg">	[&quot;1+2-3+4&quot;, &quot;1&quot;, &quot;+4&quot;, rule: 'sum']
</code></pre>
<p>Of course we could write a longer RegExp match with more bracket groups, but that only works if the number of repeated terms is small and has a known maximum.</p>
<p>In general we need a PEG rule:</p>
<pre><code class="language-eg">	var sum = Grit`
		sum  := num (add num)*
		add  :~ [+-]
		num  :~ [0-9]+
	`;
</code></pre>
<p>The parse tree result for &quot;1+2-3+4&quot; will now contain all the matched terms:</p>
<pre><code class="language-eg">	[ [ '1', index: 0, input: '1+2...', rule: 'num', lastIndex: 1 ],
		[ [ [Array], [Array] ],
		[ [Array], [Array] ],
		[ [Array], [Array] ] ],
	  rule: 'sum',
	  index: 0,
	  lastIndex: 7 ]
</code></pre>
<p>The <code>sum</code> rule returns a match that is a sequence of rule matches as an array of results. The result starts with a <code>num</code> rule match, followed by any number of <code>add plus</code> rule matches.</p>
<p>To extend the example grammar to accept parentheses requires PEG rules to use recursion (RegExp rules can not):</p>
<pre><code class="language-eg">	var arith = Grit`
		exp    := term (op term)*
		term   := num / open exp close
		op     :~ [-+]
		num    :~ [0-9]+
		open   :~ [(]
		close  :~ [)]
	`;
</code></pre>
<p>The parse tree result for <code>1+2-(3+4)</code> is:</p>
<pre><code class="language-eg">	[ [ [ '1', index: 0, input: '1+2...', rule: 'num', lastIndex: 1 ],
	    rule: 'term',
	    index: 0,
	    lastIndex: 1 ],
	  [ [ [Array], [Array] ], [ [Array], [Array] ] ],
	  rule: 'exp',
	  index: 0,
	  lastIndex: 9 ]
</code></pre>
<h2>White-space</h2>
<p>Many traditional grammar parsers use a separate lexical parse to skip white-space and recognize symbols, words, and numbers as tokens. PEG grammar rules integrate this into the grammar rules, so white-space must be dealt with explicitly.</p>
<p>Here is the previous example enhanced to accept white-space:</p>
<pre><code class="language-eg">	var sum = Grit`
		exp   := term (op term)*
		term  := num / open exp close
		op    :~ \s* ([+-])
		num   :~ \s* ([0-9]+)
		open  :~ \s* [(]
		close :~ \s* [)]
	`;
</code></pre>
<p>In a PEG rule any literal text quoted with single-quote characters <code>'...'</code> will match the text inside the quote marks. Double-quotes <code>&quot;...&quot;</code> are slightly different, they will match any number of white-space characters before the quoted literal text.</p>
<p>This allows the previous example to be written as:</p>
<pre><code class="language-eg">	var sum = Grit`
		exp   := term (op term)*
		term  := num / &quot;(&quot; exp &quot;)&quot;
		op    :~ \s* ([+-])
		num   :~ \s* ([0-9]+)
	`;
</code></pre>
<h2>The Parse Tree</h2>
<p>The result of a rule match is always a JavaScript Array. The first rule in the grammar is the start rule and it will return an array with nested sub-rule array results. This is the parse tree.</p>
<p>For regular expression rules the result is a standard RegExp Array result (as documented for JavaScript), plus an extra property for the rule name that generated this match.</p>
<p>The PEG rules are an Array containing the match results of the sub-rules that matched, plus the same extra property to record the rule name.</p>
<p>An application program can access components of the parse tree. The next example illustrates this:</p>
<pre><code class="language-eg">	var sum = Grit`
		sum  := num plus*
		plus :~ %add %num
		num  :~ [0-9]+
		add  :~ [+-]
	`;

	var total = sum.parse(&quot;1+2-3+4&quot;);

	// total = [ [&quot;1&quot;, rule:'num'], [[&quot;+2&quot;, rule:'plus'], [&quot;-3&quot;, ...] ... ], rule:'sum']

	var num  = total[0];           // num = [&quot;1&quot;, rule:'num']
	var n    = Number(num[0]);     // n = 1
	var ps   = total[1];           // ps = [plus, ...]
	var p    = ps[1]               // p = [&quot;-3&quot;, rule:'plus']
	var name = p.rule              // name = 'plus'
	var op   = p[1];               // op = '-'
</code></pre>
<h2>Semantic Actions</h2>
<p>A rule may be have an optional semantic action appended after a &quot;::&quot; symbol. The action can name a function to translate a rule match result. A rule match result is an Array by default, but a semantic action can be used as a type translator to transform that into any result type the application requires.</p>
<p>For example, the <code>number</code> type translator is defined as a function that takes a RegExp match result and returns a numeric value:</p>
<pre><code class="language-eg">	var integer = Grit`
		int :~ \s* ([0-9]+) :: number
	`;

	integer.number = (_, digits) =&gt; Number(digits);

	var n = integer.parse(&quot;42&quot;); // =&gt; n = 42
</code></pre>
<p>The calling convention is: <code>number(...result)</code>, where <code>result</code> is the Array result from the RegExp rule, with its terms &quot;spread&quot; into argument values (the ... is the spread operator in JavaScript ES6). In this case it is the first bracket field that is translated into a numeric value.</p>
<p>The next example translates the date format: m/d/y into a: y-m-d format:</p>
<pre><code class="language-eg">	var mdy = Grit`
		mdy :~ (\d\d?)/(\d\d?)/(\d{4}) :: ymd
	`;

	mdy.ymd = (_, m, d, y) =&gt; `${y}-${m}-${d}`;

	var d = mdy.parse(&quot;3/4/2015&quot;); // =&gt; &quot;2015-3-4&quot;
</code></pre>
<p>The first argument will be the full RegExp match, but that is not required for this example. The other arguments supply the RegExp bracket group match result fields, which the <code>ymd</code> function has named <code>m, d, y</code>.</p>
<p>In the next example the type translator returns a JavaScript Date object:</p>
<pre><code class="language-eg">	var mdy = Grit`
		mdy :~ (\d\d?)/(\d\d?)/(\d{4}) :: date
	`;

	mdy.date = (_, m, d, y) =&gt;  new Date(Number(y), Number(m), Number(d));

	var d = mdy.parse(&quot;3/4/2015&quot;); // =&gt; Sat Apr 04 2015 00:00:00 GMT-0400 (EDT)
</code></pre>
<p>If the type translator is specific to an individual rule then it may be written as an anonoymous function directly in that rule. Here is the same exmple again, this time written as an anyonymous function:</p>
<pre><code class="language-eg">	var mdy = Grit`
		mdy :~ (\d\d?)/(\d\d?)/(\d{4}) :: (_, m, d, y) =&gt; new Date(Number(y), Number(m), Number(d))
	`;

	var d = mdy.parse(&quot;3/4/2015&quot;); // =&gt; Sat Apr 04 2015 00:00:00 GMT-0400 (EDT)
</code></pre>
<p>The next example translates the input string into an HTML time element (a string value).</p>
<pre><code class="language-eg">	var mdy = Grit`
		mdy :~ (\d\d?)/(\d\d?)/(\d{4}) :: (mdy, m, d, y) =&gt;
				&quot;&lt;time datetime='&quot;+y+&quot;-&quot;+m+&quot;-&quot;+d+&quot;'&gt;&quot;+mdy+&quot;&lt;/time&gt;&quot;
	`;

	var d = mdy.parse(&quot;3/4/2015&quot;); // =&gt; &quot;&lt;time datetime='2015-3-4'&gt;3/4/2015&lt;/time&gt;&quot;
</code></pre>
<p>A JavaScript template string <code>(</code>...<code>)</code> can interpolate any JavaScript expressions enclosed in <code>${ ... }</code>, so the function definition may contain a nested template string with it's own interpolation:</p>
<pre><code class="language-eg">	var mdy = Grit`
		mdy :~ (\d\d?)/(\d\d?)/(\d{4}) :: ${ (mdy, m, d, y) =&gt;
				`&lt;time datetime='${y}-${m}-${d}'&gt;${mdy}&lt;/time&gt;`
		}
	`;
</code></pre>
<p>A type translator works in much the same way on PEG grammar rules. In this case the PEG rule result terms are supplied as arguments to the type translator rather than the RegExp fields:</p>
<pre><code class="language-eg">	var expr = Grit`
		sum  := num op num    :: calc
		num  :~ \s* ([0-9]+)  :: number
		op   :~ \s* ([+-])    :: string
	`;

	expr.string = (_, str) =&gt; str;
	expr.number = (_, digits) =&gt; Number(digits);
	expr.calc   = (n, op, m) =&gt; op === '+'? n+m : n-m;

	var x = expr.parse(&quot;12 + 30&quot;); // x = 42
</code></pre>
<p>The custom function <code>calc</code> takes the result of the sum rule and calculates a numeric value from the component parts.</p>
<p>The pattern in the <code>sum</code> rule is in the form of a binary infix operator, and a generic infix function can be defined to handle this pattern with helper functions for the required operators:</p>
<pre><code class="language-eg">	var expr = Grit`
		sum  := num op num    :: infix
		num  :~ \s* ([0-9]+)  :: number
		op   :~ \s* ([+-])    :: string
	`;

	exp.infix = (n, op, m) =&gt; exp[op](n,m);

	expr['+'] = (n, m) =&gt; n+m;
	expr['-'] = (n, m) =&gt; n-m;
</code></pre>
<p>The <code>infix</code> function uses the value of the <code>op</code> to select a custom function to perform the required operation. The infix function can be used with different application types and any number of operators can be defined.</p>
<p>Now consider a more general grammar that can match a list of infix operators:</p>
<pre><code class="language-eg">	var expr = Grit`
		sum  := num (op num)* :: reduce
		num  :~ \s* ([0-9]+)  :: number
		op   :~ \s* ([+-])    :: string
	`;

	expr.reduce = (x, ops) =&gt; // x (op y)* =&gt; z
		ops.reduce((z,[op,y]) =&gt; arith[op](z,y), x)

	expr['+'] = (n, m) =&gt; n+m;
	expr['-'] = (n, m) =&gt; n-m;

	console.log( expr.parse(&quot;1+2-3+4&quot;) ); // =&gt; 4
</code></pre>
<p>The <code>reduce</code> function works with left assciative operators, a similar <code>reduceRight</code> function can be defined for right associative operators.</p>
<h2>Left Recursion</h2>
<p>Traditional grammar rules use left recursion to parse a left associative tree, and right recursion for right association. PEG grammar rules typically use iteration to generate a flat list.</p>
<p>For example, the string &quot;a•b•c•d&quot; may be parsed with three different grammar rules:</p>
<pre><code class="language-eg">	exp := exp op x   =&gt;  (((a•b)•c)•d)      left associate -- but no left recursion in Grit

	exp := x op exp   =&gt;  (a•(b•(c•d)))      right associate

	exp := x (op x)*  =&gt;  (a((•b)(•c)(•d)))  flat list -- idiomatic Grit PEG form
</code></pre>
<p>All three grammar rules recognise the same input language, it is only the parse tree structures that differ. The Grit grammar does not support left recursion, but the same effect can be achieved by matching the input as a flat list, and then using a function to translate that into left associative list as required.</p>
<p>The <code>reduce</code> function can be used to evaulate left (or right) associate operators:</p>
<pre><code class="language-eg">	reduce       (a((•b)(•c)(•d)))  =&gt; (((a•b)•c)•d)

	reduceRight  (a((•b)(•c)(•d)))  =&gt; (a•(b•(c•d)))
</code></pre>
<p>The <code>reduce</code> function takes an application function to evaluates each (x•y) binary expression in order to reduce a flat list to a single value.</p>
<h2>Result Types</h2>
<p>A semantic action may return almost any type except for a special value that is reserved to mean that the rule has failed. In JavaScript the <code>null</code> or <code>undefined</code> types will cause the rule to fail, any other value may be returned.</p>
<p>The ability for a type translator to cause a rule to fail is important in some applications. For example, let's assume that the grammar has a set of key words or symbols to match. A simple way to do that is with a RegExp rule:</p>
<pre><code class="language-eg">	var symbol = Grit`
		sym :~ \s* (alpha|beta|gamma|....)
	`;
</code></pre>
<p>This approach is very fast, but it is a linear search, so for a very large symbol table there are other algorithms that will run faster. In addition to matching the input an application will often want to use a type translator to map the input match into a symbol value:</p>
<pre><code class="language-eg">	var symbol = Grit`
		sym :~ \s* (alpha|beta|gamma|....)  :: lookup
	`;

	symbol.lookup = (_, sym) =&gt; symbol.symbolMap[sym];

	symbol.symbolMap = {
		&quot;alpha&quot; : &quot;&amp;#x3b1;&quot;,
		&quot;beta&quot;  : &quot;&amp;#x3b2;&quot;,
		...
	}
</code></pre>
<p>In this case the keys of the symbolMap are repeated in the RegExp. To avoid that, the type translator may simply lookup any key word token and return a null value to fail the rule if is there is no such key. A type translator can thus eliminate the need to repeat the key values in the RegExp. A token for any potental key word can be matched:</p>
<pre><code class="language-eg">	var symbol = Grit`
		sym :~ \s* (\w+) :: lookup
	`;

	symbol.lookup = (_, sym) =&gt; symbol.symbolMap[sym];

	var x = symbol.parse('dot'); // x = '•'
</code></pre>
<p>This rule is fast and efficient and it returns the value from the symbolMap lookup (or the rule fails). The symbol table may be managed in the application outside the grammar.</p>
<p>This use of a lookup function to check a token in a map is very flexible and general purpose, but there is an extreme case that it can't quite handle. This is when the length of the keys in the map are many different lengths, and the grammar requires the longest token match. This can be approximated with a separate map for each key length, and then matching for the longest key length token first, and if that fails then try the next longest key length, and so on. If that approach is not good enough then the semantic action can be made to act as a parser function, as explained in the next section.</p>
<h2>Parser Functions</h2>
<p>There are some context sensitive grammars that can not be expressed with a PEG grammar (or in any other Context Free grammar language). These problems can be solved by allowing a semantic action to take over and act as a parser. A semantic action can save data for context sensitive parsing, and it may examine the input at the current position and advance the position to generate a match, or fail.</p>
<p>Since this technique can use the host programming language to do anything you like it is the ultimate escape hatch for difficult grammars, or for performance enhancements. The down side is that it allows the grammar to degenerate into an ad-hoc programming language solution that may be quite difficult to define in a specification that is fully portable to other implementations.</p>
<p>A simple example of a context sensitive grammar is the use of indentation for nesting, where the indentation must be matched with a previous indentation inset. The standard way to avoid this problem in the grammar is to use a lexer that generates an INDENT token when the start of an indented block is found, and one or more DEDENT tokens at the end of indentation(s). Standard grammar rules can then use these tokens exactly like nested brackets are used. For example as a {...} block in a programming language grammar, or the parenthesis (...) in S-expressions grammar.</p>
<p>Here is an example of a lexer that generates token objects for each line of input with its line number and indentation level. It also generates a failure if there is an error in the indentation. The indentation can be spaces or tabs, but it is an error if they are not consistent, the indentation of each line in each indented block must have exactly the same inset margin. The semantic action called <code>line</code> compares the inset of the current line with the current inset margin and maintains a stack of indentation levels.</p>
<pre><code class="language-eg">	var lines = Grit(`
		lines  := line*
		line   :~ (%inset) (%ln) %nl?   :: line
		inset  :~ [ \\t]*
		ln     :~ [^\\n\\r]*
		nl     :~ \\n|\\r\\n?
	`);

	lines.line = (_, inset, line) =&gt; {
		var lnum = this.lnum;
		if (!lnum) {
			this.lnum = lnum = 1;
			this.margins = [''];
		}
		this.lnum += 1;

		var margins = this.margins;
		var margin = margins[margins.length-1];

		if ( line.length === 0 || inset === margin ) {
			return { lnum, indent:margins.length-1, line };
		} else if (inset.length &gt; margin.length) {
			if (inset.indexOf(margin) === 0) { // INDENT
				margins.push(inset);
				return { lnum, indent:margins.length-1, line };
			}
		} else if (inset.length &lt; margin.length) {
			var m = margins.length-1;
			while (m &gt; 0 &amp;&amp; margin.indexOf(inset) === 0) { // DEDENT
				m -= 1;
				margin = margins[m];
				if (inset === margin) {
					this.margins = margins.slice(0,m+1);
					return { lnum, indent:m, line };
				}
			}
		}

		var fault = [inset, margins];
		console.log('Bad',[inset], margins);
		this.margins = [''];
		if (inset !== '') this.margins = ['', inset];
		return { lnum, indent:this.margins.length-1, fault, line };

	}

	var txt = `
		## Hello World

		A para..

		eg
			indented..

		Another para ...
	`;

	var tokens = lines.parse(txt);
	console.log(tokens);
</code></pre>
<p>The data for the line numbering and the stack of margin indentations are saved in the context of the parse (as <code>this.lnum</code>, and <code>this.margins</code>). The input and the current position are also available in this context, but they are not needed for this particular example. This example could be used as a lexer to feed tokens into another grammar, or it could be embedded into a larger Grit grammar.</p>
<h2>Trace Reporting</h2>
<p>It is easy to get grammar rules wrong, and hard to sort them out when you do. To help with this a trace report can be generated for any grammar rule by inserting a <code>$</code> before the semantic action. To show how this works we can use our first example again:</p>
<pre><code class="language-eg">	var arith = Grit`
		exp    := sum (addop sum)*       :: reduce
		sum    := term (mulop term)*     :: $ reduce
		term   := num / &quot;(&quot; exp ')'      :: term
		addop  :~ \s*([-+])              :: string
		mulop  :~ \s*([*/])              :: string
		num    :~ \s*([0-9]+)\s*         :: number
	`;

	arith.string = (_, str) =&gt; str
	arith.number = (_, num) =&gt; Number(num)
	arith.term   = (a, b, c) =&gt; b || a
	arith.reduce = (x, ops) =&gt; ops.reduce((z,[op,y])=&gt;arith[op](z,y),x)

	arith['+'] = (n,m) =&gt; n+m;
	arith['-'] = (n,m) =&gt; n-m;
	arith['*'] = (n,m) =&gt; n*m;
	arith['/'] = (n,m) =&gt; n/m;

	var x = arith.parse(&quot;1+2*3&quot;)
</code></pre>
<p>A trace report will be generated for the <code>sum</code> rule that has a <code>$</code> prefix before the semantic action (any number of rules may have a <code>$</code> prefix). For this example the <code>sum</code> rule will match twice:</p>
<pre><code class="language-eg">	1+2*3
	^^ 0..1 exp sum mulop !
	[ 1, [], rule: 'sum', index: 0, lastIndex: 1 ]
	=&gt; 1

	1+2*3
	  ^  ^ 2..5 exp sum mulop !
	[ 2, [ [ '*', 3 ] ], rule: 'sum', index: 2, lastIndex: 5 ]
	=&gt; 6
</code></pre>
<ul>
<li>
<p>The first line of the trace record shows the input string around the match result.</p>
</li>
<li>
<p>The second line shows the cursor positions <code>^</code> for the index range that was matched. Then the numeric values of the index range, followed by a list of all the rule calls that lead to this result. An <code>!</code> in this list indicates that the previous rule in the list failed.</p>
</li>
<li>
<p>The third line shows the Array result generated by the rule match. This will contain the input arguments to the semantic action.</p>
</li>
<li>
<p>The final line starts with a <code>=&gt;</code> and shows the value returned by the semantic action (if there is one).</p>
</li>
</ul>
<h2>Appendix: Grit In Grit</h2>
<p>The grammar for the Grit grammar rules can be defined in Grit. The interpretation of the regular expression syntax and the semantic action syntax depends on the host programming language.</p>
<pre><code class="language-eg">	var grit = Grit`
		grit  := ws (rule ws)+ :: rules
		rule  := id ws body ('::' act)? :: rule
		body  := ':=' peg / ':~' rex / '::' act
		peg   := seq ('/' seq)*
		seq   := sp (pre? term rep? sp (!next ws)? )+
		term  := id / quote / '(' peg ')'
		rex   := sp (reg (!'::' !next ws)?)*
		act   := (line (!next ws)?)*
		reg   :~ (?: [^:\n\r]* (?: :[^:])?)*
		line  :~ [^\n\r]*
		next  :~ [\n\r]+ [ \t]* %id \s* :[=~:]
		id    :~ %name | %quote
		name  :~ [a-zA-Z]\w*
		quote :~ '[^']*' | &quot;[^&quot;]*&quot;
		pre   :~ [&amp;!]
		rep   :~ [*+?]
		sp    :~ [ \t]*
		ws    :~ \s*
	`;

	grit.rules = (ws, rules) =&gt; rules.map((rule)=&gt;rule[0])

	grit.rule = function (name, body, actn) {
		var type = body[0][1]; // :=|:~|::
		var body = grit.flatten(body[1]);
		var act = actn[0]? grit.flatten(actn[0][1]) : &quot;&quot;;
		if (type === '::') {act = body.trim(); body = &quot;&quot;;}
		var term = {name:name[0], type, body, act};
		return term;
	}
	
	grit.flatten = function (list) {
		return list.reduce(function (a, b) {
			return a.concat(Array.isArray(b) ? grit.flatten(b) : b);
		}, []);
	}
</code></pre>
<style type="text/css">
	body {
		font-family: 'Helvetica Neue', Helvetica, Arial, serif;
		font-size: 1em;
		line-height: 1.5;
		color: #505050;
	}
	code.language-eg { display:block; background:whitesmoke; margin:0pt 10pt;}
</style>
